/* stats.c generated by valac 0.44.0, the Vala compiler
 * generated from stats.vala, do not modify */

#include <glib-object.h>
#include <glib.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <glib/gstdio.h>
#include <gio/gio.h>

#define VALA_DEVELOP_TYPE_SSYS_STATS (vala_develop_ssys_stats_get_type ())
typedef struct _valaDevelopSSysStats valaDevelopSSysStats;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _valaDevelopSSysStats {
	guint priv;
	guint shared;
	guint privPlusShared;
	guint total;
	guint used;
	guint64 cpuTotal;
	guint64 cpuUsed;
	gdouble loadAvg1;
	gdouble loadAvg5;
	gdouble loadAvg15;
};

GType vala_develop_ssys_stats_get_type (void) G_GNUC_CONST;
valaDevelopSSysStats* vala_develop_ssys_stats_dup (const valaDevelopSSysStats* self);
void vala_develop_ssys_stats_free (valaDevelopSSysStats* self);
void vala_develop_GetSysStats (GPid pid,
                               gboolean totalStats,
                               valaDevelopSSysStats* result);
static void _vala_array_add21 (gchar** * array,
                        int* length,
                        int* size,
                        gchar* value);
static void _vala_array_add22 (gchar** * array,
                        int* length,
                        int* size,
                        gchar* value);
static void _vala_array_add23 (gchar** * array,
                        int* length,
                        int* size,
                        gchar* value);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

valaDevelopSSysStats*
vala_develop_ssys_stats_dup (const valaDevelopSSysStats* self)
{
	valaDevelopSSysStats* dup;
	dup = g_new0 (valaDevelopSSysStats, 1);
	memcpy (dup, self, sizeof (valaDevelopSSysStats));
	return dup;
}

void
vala_develop_ssys_stats_free (valaDevelopSSysStats* self)
{
	g_free (self);
}

GType
vala_develop_ssys_stats_get_type (void)
{
	static volatile gsize vala_develop_ssys_stats_type_id__volatile = 0;
	if (g_once_init_enter (&vala_develop_ssys_stats_type_id__volatile)) {
		GType vala_develop_ssys_stats_type_id;
		vala_develop_ssys_stats_type_id = g_boxed_type_register_static ("valaDevelopSSysStats", (GBoxedCopyFunc) vala_develop_ssys_stats_dup, (GBoxedFreeFunc) vala_develop_ssys_stats_free);
		g_once_init_leave (&vala_develop_ssys_stats_type_id__volatile, vala_develop_ssys_stats_type_id);
	}
	return vala_develop_ssys_stats_type_id__volatile;
}

/**
* Gets actual (caller) or specific process and system stats.
* @param pid specific process id to get infos from or -1 for own process
* @param totalStatus if ``true``, return totals system stats too (else
* total system stats are alle 0)
* @return syste stats info structure {@link SSysStats}
* @see SSysStats
*/
static void
_vala_array_add21 (gchar** * array,
                   int* length,
                   int* size,
                   gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static void
_vala_array_add22 (gchar** * array,
                   int* length,
                   int* size,
                   gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static void
_vala_array_add23 (gchar** * array,
                   int* length,
                   int* size,
                   gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static glong
string_strnlen (gchar* str,
                glong maxlen)
{
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	_tmp0_ = memchr (str, 0, (gsize) maxlen);
	end = _tmp0_;
	_tmp1_ = end;
	if (_tmp1_ == NULL) {
		result = maxlen;
		return result;
	} else {
		gchar* _tmp2_;
		_tmp2_ = end;
		result = (glong) (_tmp2_ - str);
		return result;
	}
}

static gchar*
string_substring (const gchar* self,
                  glong offset,
                  glong len)
{
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	if (offset >= ((glong) 0)) {
		_tmp0_ = len >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		string_length = string_strnlen ((gchar*) self, offset + len);
	} else {
		gint _tmp1_;
		gint _tmp2_;
		_tmp1_ = strlen (self);
		_tmp2_ = _tmp1_;
		string_length = (glong) _tmp2_;
	}
	if (offset < ((glong) 0)) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= ((glong) 0), NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < ((glong) 0)) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	_tmp3_ = g_strndup (((gchar*) self) + offset, (gsize) len);
	result = _tmp3_;
	return result;
}

static gint
string_index_of_char (const gchar* self,
                      gunichar c,
                      gint start_index)
{
	gint result = 0;
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_utf8_strchr (((gchar*) self) + start_index, (gssize) -1, c);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	if (_tmp1_ != NULL) {
		gchar* _tmp2_;
		_tmp2_ = _result_;
		result = (gint) (_tmp2_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}

static gchar*
string_chug (const gchar* self)
{
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strchug (_tmp1_);
	result = _result_;
	return result;
}

void
vala_develop_GetSysStats (GPid pid,
                          gboolean totalStats,
                          valaDevelopSSysStats* result)
{
	valaDevelopSSysStats inf = {0};
	valaDevelopSSysStats _tmp0_ = {0};
	static const guint pageSizeK = 4U;
	gchar* _tmp1_ = NULL;
	gchar* procDir = NULL;
	gchar* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gboolean _tmp8_;
	GError* _inner_error0_ = NULL;
	_tmp0_.priv = (guint) 0;
	_tmp0_.shared = (guint) 0;
	_tmp0_.privPlusShared = (guint) 0;
	_tmp0_.total = (guint) 0;
	_tmp0_.used = (guint) 0;
	_tmp0_.cpuTotal = (guint64) 0;
	_tmp0_.cpuUsed = (guint64) 0;
	_tmp0_.loadAvg1 = 0.0;
	_tmp0_.loadAvg5 = 0.0;
	_tmp0_.loadAvg15 = 0.0;
	inf = _tmp0_;
	if (pid == ((GPid) -1)) {
		gchar* _tmp2_;
		_tmp2_ = g_strdup ("/proc/self/");
		_g_free0 (_tmp1_);
		_tmp1_ = _tmp2_;
	} else {
		gchar* _tmp3_;
		_tmp3_ = g_strdup_printf ("/proc/%lld/", pid);
		_g_free0 (_tmp1_);
		_tmp1_ = _tmp3_;
	}
	_tmp4_ = g_strdup (_tmp1_);
	procDir = _tmp4_;
	_tmp5_ = procDir;
	_tmp6_ = g_strconcat (_tmp5_, "smaps", NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_file_test (_tmp7_, G_FILE_TEST_EXISTS);
	_g_free0 (_tmp7_);
	if (_tmp8_) {
		{
			GFile* file = NULL;
			const gchar* _tmp9_;
			gchar* _tmp10_;
			gchar* _tmp11_;
			GFile* _tmp12_;
			GFile* _tmp13_;
			GFileInputStream* _tmp14_ = NULL;
			GFile* _tmp15_;
			GFileInputStream* _tmp16_;
			GDataInputStream* dis = NULL;
			GDataInputStream* _tmp17_;
			gchar* line = NULL;
			gchar** priLines = NULL;
			gchar** _tmp18_;
			gint priLines_length1;
			gint _priLines_size_;
			gchar** shaLines = NULL;
			gchar** _tmp19_;
			gint shaLines_length1;
			gint _shaLines_size_;
			gchar** pssLines = NULL;
			gchar** _tmp20_;
			gint pssLines_length1;
			gint _pssLines_size_;
			guint priKb = 0U;
			guint shaKb = 0U;
			guint pssKb = 0U;
			gchar** _tmp38_;
			gint _tmp38__length1;
			gchar** _tmp44_;
			gint _tmp44__length1;
			gchar** _tmp50_;
			gint _tmp50__length1;
			gchar** _tmp56_;
			gint _tmp56__length1;
			valaDevelopSSysStats _tmp57_;
			valaDevelopSSysStats _tmp58_;
			_tmp9_ = procDir;
			_tmp10_ = g_strconcat (_tmp9_, "smaps", NULL);
			_tmp11_ = _tmp10_;
			_tmp12_ = g_file_new_for_path (_tmp11_);
			_tmp13_ = _tmp12_;
			_g_free0 (_tmp11_);
			file = _tmp13_;
			_tmp15_ = file;
			_tmp16_ = g_file_read (_tmp15_, NULL, &_inner_error0_);
			_tmp14_ = _tmp16_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_object_unref0 (file);
				goto __catch64_g_error;
			}
			_tmp17_ = g_data_input_stream_new ((GInputStream*) _tmp14_);
			dis = _tmp17_;
			_tmp18_ = g_new0 (gchar*, 0 + 1);
			priLines = _tmp18_;
			priLines_length1 = 0;
			_priLines_size_ = priLines_length1;
			_tmp19_ = g_new0 (gchar*, 0 + 1);
			shaLines = _tmp19_;
			shaLines_length1 = 0;
			_shaLines_size_ = shaLines_length1;
			_tmp20_ = g_new0 (gchar*, 0 + 1);
			pssLines = _tmp20_;
			pssLines_length1 = 0;
			_pssLines_size_ = pssLines_length1;
			while (TRUE) {
				gchar* _tmp21_ = NULL;
				GDataInputStream* _tmp22_;
				gchar* _tmp23_;
				gchar* _tmp24_;
				const gchar* _tmp25_;
				const gchar* _tmp26_;
				_tmp22_ = dis;
				_tmp23_ = g_data_input_stream_read_line (_tmp22_, NULL, NULL, &_inner_error0_);
				_tmp21_ = _tmp23_;
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					pssLines = (_vala_array_free (pssLines, pssLines_length1, (GDestroyNotify) g_free), NULL);
					shaLines = (_vala_array_free (shaLines, shaLines_length1, (GDestroyNotify) g_free), NULL);
					priLines = (_vala_array_free (priLines, priLines_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (line);
					_g_object_unref0 (dis);
					_g_object_unref0 (_tmp14_);
					_g_object_unref0 (file);
					goto __catch64_g_error;
				}
				_tmp24_ = _tmp21_;
				_tmp21_ = NULL;
				_g_free0 (line);
				line = _tmp24_;
				_tmp25_ = line;
				if (!(_tmp25_ != NULL)) {
					_g_free0 (_tmp21_);
					break;
				}
				_tmp26_ = line;
				if (g_str_has_prefix (_tmp26_, "Shared")) {
					gchar** _tmp27_;
					gint _tmp27__length1;
					const gchar* _tmp28_;
					gchar* _tmp29_;
					_tmp27_ = shaLines;
					_tmp27__length1 = shaLines_length1;
					_tmp28_ = line;
					_tmp29_ = g_strdup (_tmp28_);
					_vala_array_add21 (&shaLines, &shaLines_length1, &_shaLines_size_, _tmp29_);
				} else {
					const gchar* _tmp30_;
					_tmp30_ = line;
					if (g_str_has_prefix (_tmp30_, "Private")) {
						gchar** _tmp31_;
						gint _tmp31__length1;
						const gchar* _tmp32_;
						gchar* _tmp33_;
						_tmp31_ = priLines;
						_tmp31__length1 = priLines_length1;
						_tmp32_ = line;
						_tmp33_ = g_strdup (_tmp32_);
						_vala_array_add22 (&priLines, &priLines_length1, &_priLines_size_, _tmp33_);
					} else {
						const gchar* _tmp34_;
						_tmp34_ = line;
						if (g_str_has_prefix (_tmp34_, "Pss")) {
							gchar** _tmp35_;
							gint _tmp35__length1;
							const gchar* _tmp36_;
							gchar* _tmp37_;
							_tmp35_ = pssLines;
							_tmp35__length1 = pssLines_length1;
							_tmp36_ = line;
							_tmp37_ = g_strdup (_tmp36_);
							_vala_array_add23 (&pssLines, &pssLines_length1, &_pssLines_size_, _tmp37_);
						}
					}
				}
				_g_free0 (_tmp21_);
			}
			priKb = (guint) 0;
			shaKb = (guint) 0;
			pssKb = (guint) 0;
			_tmp38_ = priLines;
			_tmp38__length1 = priLines_length1;
			{
				gchar** str_collection = NULL;
				gint str_collection_length1 = 0;
				gint _str_collection_size_ = 0;
				gint str_it = 0;
				str_collection = _tmp38_;
				str_collection_length1 = _tmp38__length1;
				for (str_it = 0; str_it < _tmp38__length1; str_it = str_it + 1) {
					gchar* _tmp39_;
					gchar* str = NULL;
					_tmp39_ = g_strdup (str_collection[str_it]);
					str = _tmp39_;
					{
						const gchar* _tmp40_;
						const gchar* _tmp41_;
						gchar* _tmp42_;
						gchar* _tmp43_;
						_tmp40_ = str;
						_tmp41_ = str;
						_tmp42_ = string_substring (_tmp40_, (glong) (string_index_of_char (_tmp41_, (gunichar) ':', 0) + 1), (glong) -1);
						_tmp43_ = _tmp42_;
						priKb = priKb + atoi (_tmp43_);
						_g_free0 (_tmp43_);
						_g_free0 (str);
					}
				}
			}
			_tmp44_ = shaLines;
			_tmp44__length1 = shaLines_length1;
			{
				gchar** str_collection = NULL;
				gint str_collection_length1 = 0;
				gint _str_collection_size_ = 0;
				gint str_it = 0;
				str_collection = _tmp44_;
				str_collection_length1 = _tmp44__length1;
				for (str_it = 0; str_it < _tmp44__length1; str_it = str_it + 1) {
					gchar* _tmp45_;
					gchar* str = NULL;
					_tmp45_ = g_strdup (str_collection[str_it]);
					str = _tmp45_;
					{
						const gchar* _tmp46_;
						const gchar* _tmp47_;
						gchar* _tmp48_;
						gchar* _tmp49_;
						_tmp46_ = str;
						_tmp47_ = str;
						_tmp48_ = string_substring (_tmp46_, (glong) (string_index_of_char (_tmp47_, (gunichar) ':', 0) + 1), (glong) -1);
						_tmp49_ = _tmp48_;
						shaKb = shaKb + atoi (_tmp49_);
						_g_free0 (_tmp49_);
						_g_free0 (str);
					}
				}
			}
			_tmp50_ = pssLines;
			_tmp50__length1 = pssLines_length1;
			{
				gchar** str_collection = NULL;
				gint str_collection_length1 = 0;
				gint _str_collection_size_ = 0;
				gint str_it = 0;
				str_collection = _tmp50_;
				str_collection_length1 = _tmp50__length1;
				for (str_it = 0; str_it < _tmp50__length1; str_it = str_it + 1) {
					gchar* _tmp51_;
					gchar* str = NULL;
					_tmp51_ = g_strdup (str_collection[str_it]);
					str = _tmp51_;
					{
						const gchar* _tmp52_;
						const gchar* _tmp53_;
						gchar* _tmp54_;
						gchar* _tmp55_;
						_tmp52_ = str;
						_tmp53_ = str;
						_tmp54_ = string_substring (_tmp52_, (glong) (string_index_of_char (_tmp53_, (gunichar) ':', 0) + 1), (glong) -1);
						_tmp55_ = _tmp54_;
						pssKb = pssKb + atoi (_tmp55_);
						_g_free0 (_tmp55_);
						_g_free0 (str);
					}
				}
			}
			_tmp56_ = pssLines;
			_tmp56__length1 = pssLines_length1;
			pssKb = pssKb + ((_tmp56__length1 * 5) / 10);
			shaKb = pssKb - priKb;
			inf.priv = priKb;
			inf.shared = shaKb;
			_tmp57_ = inf;
			_tmp58_ = inf;
			inf.privPlusShared = _tmp57_.priv + _tmp58_.shared;
			pssLines = (_vala_array_free (pssLines, pssLines_length1, (GDestroyNotify) g_free), NULL);
			shaLines = (_vala_array_free (shaLines, shaLines_length1, (GDestroyNotify) g_free), NULL);
			priLines = (_vala_array_free (priLines, priLines_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (line);
			_g_object_unref0 (dis);
			_g_object_unref0 (_tmp14_);
			_g_object_unref0 (file);
		}
		goto __finally64;
		__catch64_g_error:
		{
			GError* err = NULL;
			err = _inner_error0_;
			_inner_error0_ = NULL;
			_g_error_free0 (err);
		}
		__finally64:
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_free0 (procDir);
			_g_free0 (_tmp1_);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	} else {
		{
			gchar* content = NULL;
			const gchar* _tmp59_;
			gchar* _tmp60_;
			gchar* _tmp61_;
			gchar* _tmp62_ = NULL;
			gchar** infStrArr = NULL;
			const gchar* _tmp63_;
			gchar** _tmp64_;
			gchar** _tmp65_;
			gint infStrArr_length1;
			gint _infStrArr_size_;
			guint rss = 0U;
			gchar** _tmp66_;
			gint _tmp66__length1;
			const gchar* _tmp67_;
			guint shared = 0U;
			gchar** _tmp68_;
			gint _tmp68__length1;
			const gchar* _tmp69_;
			valaDevelopSSysStats _tmp70_;
			valaDevelopSSysStats _tmp71_;
			_tmp59_ = procDir;
			_tmp60_ = g_strconcat (_tmp59_, "statm", NULL);
			_tmp61_ = _tmp60_;
			g_file_get_contents (_tmp61_, &_tmp62_, NULL, &_inner_error0_);
			_g_free0 (content);
			content = _tmp62_;
			_g_free0 (_tmp61_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_free0 (content);
				if (_inner_error0_->domain == G_FILE_ERROR) {
					goto __catch65_g_file_error;
				}
				_g_free0 (content);
				_g_free0 (procDir);
				_g_free0 (_tmp1_);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
			_tmp63_ = content;
			_tmp65_ = _tmp64_ = g_strsplit (_tmp63_, " ", 0);
			infStrArr = _tmp65_;
			infStrArr_length1 = _vala_array_length (_tmp64_);
			_infStrArr_size_ = infStrArr_length1;
			_tmp66_ = infStrArr;
			_tmp66__length1 = infStrArr_length1;
			_tmp67_ = _tmp66_[1];
			rss = ((guint) atoi (_tmp67_)) * pageSizeK;
			_tmp68_ = infStrArr;
			_tmp68__length1 = infStrArr_length1;
			_tmp69_ = _tmp68_[2];
			shared = ((guint) atoi (_tmp69_)) * pageSizeK;
			inf.priv = rss - shared;
			inf.shared = shared;
			_tmp70_ = inf;
			_tmp71_ = inf;
			inf.privPlusShared = _tmp70_.priv + _tmp71_.shared;
			infStrArr = (_vala_array_free (infStrArr, infStrArr_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (content);
		}
		goto __finally65;
		__catch65_g_file_error:
		{
			GError* err = NULL;
			err = _inner_error0_;
			_inner_error0_ = NULL;
			_g_error_free0 (err);
		}
		__finally65:
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_free0 (procDir);
			_g_free0 (_tmp1_);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	if (totalStats) {
		{
			gchar* memInf = NULL;
			gchar* _tmp72_;
			_tmp72_ = g_strdup ("");
			memInf = _tmp72_;
			if (g_file_test ("/proc/meminfo", G_FILE_TEST_EXISTS)) {
				gint totalKB = 0;
				gint freeKB = 0;
				gint bufKB = 0;
				gint cacheKB = 0;
				gchar* _tmp73_ = NULL;
				gchar** lines = NULL;
				const gchar* _tmp74_;
				gchar** _tmp75_;
				gchar** _tmp76_;
				gint lines_length1;
				gint _lines_size_;
				gboolean _tmp109_ = FALSE;
				gboolean _tmp110_ = FALSE;
				gboolean _tmp111_ = FALSE;
				totalKB = -1;
				freeKB = -1;
				bufKB = -1;
				cacheKB = -1;
				g_file_get_contents ("/proc/meminfo", &_tmp73_, NULL, &_inner_error0_);
				_g_free0 (memInf);
				memInf = _tmp73_;
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					_g_free0 (memInf);
					if (_inner_error0_->domain == G_FILE_ERROR) {
						goto __catch66_g_file_error;
					}
					_g_free0 (memInf);
					_g_free0 (procDir);
					_g_free0 (_tmp1_);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return;
				}
				_tmp74_ = memInf;
				_tmp76_ = _tmp75_ = g_strsplit (_tmp74_, "\n", 0);
				lines = _tmp76_;
				lines_length1 = _vala_array_length (_tmp75_);
				_lines_size_ = lines_length1;
				{
					gint idx = 0;
					idx = 0;
					{
						gboolean _tmp77_ = FALSE;
						_tmp77_ = TRUE;
						while (TRUE) {
							gchar** _tmp79_;
							gint _tmp79__length1;
							gboolean _tmp80_ = FALSE;
							gboolean _tmp81_ = FALSE;
							gboolean _tmp82_ = FALSE;
							gchar** tok = NULL;
							gchar** _tmp83_;
							gint _tmp83__length1;
							const gchar* _tmp84_;
							gchar** _tmp85_;
							gchar** _tmp86_;
							gint tok_length1;
							gint _tok_size_;
							gchar** _tmp87_;
							gint _tmp87__length1;
							if (!_tmp77_) {
								gint _tmp78_;
								_tmp78_ = idx;
								idx = _tmp78_ + 1;
							}
							_tmp77_ = FALSE;
							_tmp79_ = lines;
							_tmp79__length1 = lines_length1;
							if (!(idx < _tmp79__length1)) {
								break;
							}
							if (totalKB != -1) {
								_tmp82_ = freeKB != -1;
							} else {
								_tmp82_ = FALSE;
							}
							if (_tmp82_) {
								_tmp81_ = bufKB != -1;
							} else {
								_tmp81_ = FALSE;
							}
							if (_tmp81_) {
								_tmp80_ = cacheKB != -1;
							} else {
								_tmp80_ = FALSE;
							}
							if (_tmp80_) {
								break;
							}
							_tmp83_ = lines;
							_tmp83__length1 = lines_length1;
							_tmp84_ = _tmp83_[idx];
							_tmp86_ = _tmp85_ = g_strsplit (_tmp84_, ":", 0);
							tok = _tmp86_;
							tok_length1 = _vala_array_length (_tmp85_);
							_tok_size_ = tok_length1;
							_tmp87_ = tok;
							_tmp87__length1 = tok_length1;
							if (_tmp87__length1 == 2) {
								gchar** _tmp88_;
								gint _tmp88__length1;
								const gchar* _tmp89_;
								const gchar* _tmp90_;
								GQuark _tmp92_ = 0U;
								static GQuark _tmp91_label0 = 0;
								static GQuark _tmp91_label1 = 0;
								static GQuark _tmp91_label2 = 0;
								static GQuark _tmp91_label3 = 0;
								_tmp88_ = tok;
								_tmp88__length1 = tok_length1;
								_tmp89_ = _tmp88_[0];
								_tmp90_ = _tmp89_;
								_tmp92_ = (NULL == _tmp90_) ? 0 : g_quark_from_string (_tmp90_);
								if (_tmp92_ == ((0 != _tmp91_label0) ? _tmp91_label0 : (_tmp91_label0 = g_quark_from_static_string ("MemTotal")))) {
									switch (0) {
										default:
										{
											gchar** _tmp93_;
											gint _tmp93__length1;
											const gchar* _tmp94_;
											gchar* _tmp95_;
											gchar* _tmp96_;
											_tmp93_ = tok;
											_tmp93__length1 = tok_length1;
											_tmp94_ = _tmp93_[1];
											_tmp95_ = string_chug (_tmp94_);
											_tmp96_ = _tmp95_;
											totalKB = atoi (_tmp96_);
											_g_free0 (_tmp96_);
											break;
										}
									}
								} else if (_tmp92_ == ((0 != _tmp91_label1) ? _tmp91_label1 : (_tmp91_label1 = g_quark_from_static_string ("MemFree")))) {
									switch (0) {
										default:
										{
											gchar** _tmp97_;
											gint _tmp97__length1;
											const gchar* _tmp98_;
											gchar* _tmp99_;
											gchar* _tmp100_;
											_tmp97_ = tok;
											_tmp97__length1 = tok_length1;
											_tmp98_ = _tmp97_[1];
											_tmp99_ = string_chug (_tmp98_);
											_tmp100_ = _tmp99_;
											freeKB = atoi (_tmp100_);
											_g_free0 (_tmp100_);
											break;
										}
									}
								} else if (_tmp92_ == ((0 != _tmp91_label2) ? _tmp91_label2 : (_tmp91_label2 = g_quark_from_static_string ("Buffers")))) {
									switch (0) {
										default:
										{
											gchar** _tmp101_;
											gint _tmp101__length1;
											const gchar* _tmp102_;
											gchar* _tmp103_;
											gchar* _tmp104_;
											_tmp101_ = tok;
											_tmp101__length1 = tok_length1;
											_tmp102_ = _tmp101_[1];
											_tmp103_ = string_chug (_tmp102_);
											_tmp104_ = _tmp103_;
											bufKB = atoi (_tmp104_);
											_g_free0 (_tmp104_);
											break;
										}
									}
								} else if (_tmp92_ == ((0 != _tmp91_label3) ? _tmp91_label3 : (_tmp91_label3 = g_quark_from_static_string ("Cached")))) {
									switch (0) {
										default:
										{
											gchar** _tmp105_;
											gint _tmp105__length1;
											const gchar* _tmp106_;
											gchar* _tmp107_;
											gchar* _tmp108_;
											_tmp105_ = tok;
											_tmp105__length1 = tok_length1;
											_tmp106_ = _tmp105_[1];
											_tmp107_ = string_chug (_tmp106_);
											_tmp108_ = _tmp107_;
											cacheKB = atoi (_tmp108_);
											_g_free0 (_tmp108_);
											break;
										}
									}
								}
							}
							tok = (_vala_array_free (tok, tok_length1, (GDestroyNotify) g_free), NULL);
						}
					}
				}
				if (totalKB != -1) {
					_tmp111_ = freeKB != -1;
				} else {
					_tmp111_ = FALSE;
				}
				if (_tmp111_) {
					_tmp110_ = bufKB != -1;
				} else {
					_tmp110_ = FALSE;
				}
				if (_tmp110_) {
					_tmp109_ = cacheKB != -1;
				} else {
					_tmp109_ = FALSE;
				}
				if (_tmp109_) {
					inf.total = (guint) totalKB;
					inf.used = (guint) (((totalKB - freeKB) - bufKB) - cacheKB);
				}
				lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
			}
			_g_free0 (memInf);
		}
		goto __finally66;
		__catch66_g_file_error:
		{
			GError* err = NULL;
			err = _inner_error0_;
			_inner_error0_ = NULL;
			_g_error_free0 (err);
		}
		__finally66:
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_free0 (procDir);
			_g_free0 (_tmp1_);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	*result = inf;
	_g_free0 (procDir);
	_g_free0 (_tmp1_);
	return;
}

static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gint
_vala_array_length (gpointer array)
{
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

