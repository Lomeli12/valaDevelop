/* xml_configuration.c generated by valac UNKNOWN, the Vala compiler
 * generated from xml_configuration.vala, do not modify */

#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <gobject/gvaluecollector.h>
#include <gio/gio.h>

#define VALA_DEVELOP_TYPE_XML_CONFIGURATION (vala_develop_xml_configuration_get_type ())
#define VALA_DEVELOP_XML_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_DEVELOP_TYPE_XML_CONFIGURATION, valaDevelopXmlConfiguration))
#define VALA_DEVELOP_XML_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_DEVELOP_TYPE_XML_CONFIGURATION, valaDevelopXmlConfigurationClass))
#define VALA_DEVELOP_IS_XML_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_DEVELOP_TYPE_XML_CONFIGURATION))
#define VALA_DEVELOP_IS_XML_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_DEVELOP_TYPE_XML_CONFIGURATION))
#define VALA_DEVELOP_XML_CONFIGURATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_DEVELOP_TYPE_XML_CONFIGURATION, valaDevelopXmlConfigurationClass))

typedef struct _valaDevelopXmlConfiguration valaDevelopXmlConfiguration;
typedef struct _valaDevelopXmlConfigurationClass valaDevelopXmlConfigurationClass;
typedef struct _valaDevelopXmlConfigurationPrivate valaDevelopXmlConfigurationPrivate;

#define VALA_DEVELOP_TYPE_SETTINGS (vala_develop_settings_get_type ())
#define VALA_DEVELOP_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_DEVELOP_TYPE_SETTINGS, valaDevelopSettings))
#define VALA_DEVELOP_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_DEVELOP_TYPE_SETTINGS, valaDevelopSettingsClass))
#define VALA_DEVELOP_IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_DEVELOP_TYPE_SETTINGS))
#define VALA_DEVELOP_IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_DEVELOP_TYPE_SETTINGS))
#define VALA_DEVELOP_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_DEVELOP_TYPE_SETTINGS, valaDevelopSettingsClass))

typedef struct _valaDevelopSettings valaDevelopSettings;
typedef struct _valaDevelopSettingsClass valaDevelopSettingsClass;
#define _vala_develop_settings_unref0(var) ((var == NULL) ? NULL : (var = (vala_develop_settings_unref (var), NULL)))
typedef struct _valaDevelopParamSpecXmlConfiguration valaDevelopParamSpecXmlConfiguration;
typedef struct _valaDevelopSettingsPrivate valaDevelopSettingsPrivate;
#define _g_key_file_unref0(var) ((var == NULL) ? NULL : (var = (g_key_file_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _valaDevelopParamSpecSettings valaDevelopParamSpecSettings;

struct _valaDevelopXmlConfiguration {
	GTypeInstance parent_instance;
	volatile int ref_count;
	valaDevelopXmlConfigurationPrivate * priv;
};

struct _valaDevelopXmlConfigurationClass {
	GTypeClass parent_class;
	void (*finalize) (valaDevelopXmlConfiguration *self);
};

struct _valaDevelopParamSpecXmlConfiguration {
	GParamSpec parent_instance;
};

struct _valaDevelopSettings {
	GTypeInstance parent_instance;
	volatile int ref_count;
	valaDevelopSettingsPrivate * priv;
};

struct _valaDevelopSettingsClass {
	GTypeClass parent_class;
	void (*finalize) (valaDevelopSettings *self);
};

struct _valaDevelopSettingsPrivate {
	GKeyFile* _key;
	gchar* user_config_folder;
};

struct _valaDevelopParamSpecSettings {
	GParamSpec parent_instance;
};

static gpointer vala_develop_xml_configuration_parent_class = NULL;
static valaDevelopSettings* vala_develop_xml_configuration__settings;
static valaDevelopSettings* vala_develop_xml_configuration__settings = NULL;
static gint valaDevelopSettings_private_offset;
static gpointer vala_develop_settings_parent_class = NULL;

gpointer vala_develop_xml_configuration_ref (gpointer instance);
void vala_develop_xml_configuration_unref (gpointer instance);
GParamSpec* vala_develop_param_spec_xml_configuration (const gchar* name,
                                                       const gchar* nick,
                                                       const gchar* blurb,
                                                       GType object_type,
                                                       GParamFlags flags);
void vala_develop_value_set_xml_configuration (GValue* value,
                                               gpointer v_object);
void vala_develop_value_take_xml_configuration (GValue* value,
                                                gpointer v_object);
gpointer vala_develop_value_get_xml_configuration (const GValue* value);
GType vala_develop_xml_configuration_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (valaDevelopXmlConfiguration, vala_develop_xml_configuration_unref)
gpointer vala_develop_settings_ref (gpointer instance);
void vala_develop_settings_unref (gpointer instance);
GParamSpec* vala_develop_param_spec_settings (const gchar* name,
                                              const gchar* nick,
                                              const gchar* blurb,
                                              GType object_type,
                                              GParamFlags flags);
void vala_develop_value_set_settings (GValue* value,
                                      gpointer v_object);
void vala_develop_value_take_settings (GValue* value,
                                       gpointer v_object);
gpointer vala_develop_value_get_settings (const GValue* value);
GType vala_develop_settings_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (valaDevelopSettings, vala_develop_settings_unref)
void vala_develop_xml_configuration_load (void);
valaDevelopSettings* vala_develop_settings_new (void);
valaDevelopSettings* vala_develop_settings_construct (GType object_type);
void vala_develop_settings_load (valaDevelopSettings* self);
void vala_develop_xml_configuration_remove (const gchar* key);
void vala_develop_settings_remove (valaDevelopSettings* self,
                                   const gchar* key);
gboolean vala_develop_xml_configuration_has_key (const gchar* key);
gboolean vala_develop_settings_has_key (valaDevelopSettings* self,
                                        const gchar* key);
void vala_develop_xml_configuration_save (void);
void vala_develop_settings_save (valaDevelopSettings* self);
valaDevelopXmlConfiguration* vala_develop_xml_configuration_new (void);
valaDevelopXmlConfiguration* vala_develop_xml_configuration_construct (GType object_type);
valaDevelopSettings* vala_develop_xml_configuration_get_Setting (void);
static void vala_develop_xml_configuration_finalize (valaDevelopXmlConfiguration * obj);
gchar* vala_develop_settings_get (valaDevelopSettings* self,
                                  const gchar* key);
void vala_develop_settings_set (valaDevelopSettings* self,
                                const gchar* key,
                                const gchar* val);
static void vala_develop_settings_finalize (valaDevelopSettings * obj);

void
vala_develop_xml_configuration_load (void)
{
	valaDevelopSettings* _tmp0_;
	valaDevelopSettings* _tmp1_;
	_tmp0_ = vala_develop_settings_new ();
	_vala_develop_settings_unref0 (vala_develop_xml_configuration__settings);
	vala_develop_xml_configuration__settings = _tmp0_;
	_tmp1_ = vala_develop_xml_configuration__settings;
	vala_develop_settings_load (_tmp1_);
}

void
vala_develop_xml_configuration_remove (const gchar* key)
{
	valaDevelopSettings* _tmp0_;
	g_return_if_fail (key != NULL);
	_tmp0_ = vala_develop_xml_configuration__settings;
	vala_develop_settings_remove (_tmp0_, key);
}

gboolean
vala_develop_xml_configuration_has_key (const gchar* key)
{
	gboolean result = FALSE;
	valaDevelopSettings* _tmp0_;
	g_return_val_if_fail (key != NULL, FALSE);
	_tmp0_ = vala_develop_xml_configuration__settings;
	result = vala_develop_settings_has_key (_tmp0_, key);
	return result;
}

void
vala_develop_xml_configuration_save (void)
{
	valaDevelopSettings* _tmp0_;
	_tmp0_ = vala_develop_xml_configuration__settings;
	vala_develop_settings_save (_tmp0_);
}

valaDevelopXmlConfiguration*
vala_develop_xml_configuration_construct (GType object_type)
{
	valaDevelopXmlConfiguration* self = NULL;
	self = (valaDevelopXmlConfiguration*) g_type_create_instance (object_type);
	return self;
}

valaDevelopXmlConfiguration*
vala_develop_xml_configuration_new (void)
{
	return vala_develop_xml_configuration_construct (VALA_DEVELOP_TYPE_XML_CONFIGURATION);
}

valaDevelopSettings*
vala_develop_xml_configuration_get_Setting (void)
{
	valaDevelopSettings* result;
	valaDevelopSettings* _tmp0_;
	_tmp0_ = vala_develop_xml_configuration__settings;
	result = _tmp0_;
	return result;
}

static void
vala_develop_value_xml_configuration_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
vala_develop_value_xml_configuration_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		vala_develop_xml_configuration_unref (value->data[0].v_pointer);
	}
}

static void
vala_develop_value_xml_configuration_copy_value (const GValue* src_value,
                                                 GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = vala_develop_xml_configuration_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
vala_develop_value_xml_configuration_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
vala_develop_value_xml_configuration_collect_value (GValue* value,
                                                    guint n_collect_values,
                                                    GTypeCValue* collect_values,
                                                    guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		valaDevelopXmlConfiguration * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = vala_develop_xml_configuration_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
vala_develop_value_xml_configuration_lcopy_value (const GValue* value,
                                                  guint n_collect_values,
                                                  GTypeCValue* collect_values,
                                                  guint collect_flags)
{
	valaDevelopXmlConfiguration ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = vala_develop_xml_configuration_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
vala_develop_param_spec_xml_configuration (const gchar* name,
                                           const gchar* nick,
                                           const gchar* blurb,
                                           GType object_type,
                                           GParamFlags flags)
{
	valaDevelopParamSpecXmlConfiguration* spec;
	g_return_val_if_fail (g_type_is_a (object_type, VALA_DEVELOP_TYPE_XML_CONFIGURATION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
vala_develop_value_get_xml_configuration (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_DEVELOP_TYPE_XML_CONFIGURATION), NULL);
	return value->data[0].v_pointer;
}

void
vala_develop_value_set_xml_configuration (GValue* value,
                                          gpointer v_object)
{
	valaDevelopXmlConfiguration * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_DEVELOP_TYPE_XML_CONFIGURATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALA_DEVELOP_TYPE_XML_CONFIGURATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		vala_develop_xml_configuration_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		vala_develop_xml_configuration_unref (old);
	}
}

void
vala_develop_value_take_xml_configuration (GValue* value,
                                           gpointer v_object)
{
	valaDevelopXmlConfiguration * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_DEVELOP_TYPE_XML_CONFIGURATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALA_DEVELOP_TYPE_XML_CONFIGURATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		vala_develop_xml_configuration_unref (old);
	}
}

static void
vala_develop_xml_configuration_class_init (valaDevelopXmlConfigurationClass * klass,
                                           gpointer klass_data)
{
	vala_develop_xml_configuration_parent_class = g_type_class_peek_parent (klass);
	((valaDevelopXmlConfigurationClass *) klass)->finalize = vala_develop_xml_configuration_finalize;
}

static void
vala_develop_xml_configuration_instance_init (valaDevelopXmlConfiguration * self,
                                              gpointer klass)
{
	self->ref_count = 1;
}

static void
vala_develop_xml_configuration_finalize (valaDevelopXmlConfiguration * obj)
{
	valaDevelopXmlConfiguration * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALA_DEVELOP_TYPE_XML_CONFIGURATION, valaDevelopXmlConfiguration);
	g_signal_handlers_destroy (self);
}

GType
vala_develop_xml_configuration_get_type (void)
{
	static volatile gsize vala_develop_xml_configuration_type_id__volatile = 0;
	if (g_once_init_enter (&vala_develop_xml_configuration_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { vala_develop_value_xml_configuration_init, vala_develop_value_xml_configuration_free_value, vala_develop_value_xml_configuration_copy_value, vala_develop_value_xml_configuration_peek_pointer, "p", vala_develop_value_xml_configuration_collect_value, "p", vala_develop_value_xml_configuration_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (valaDevelopXmlConfigurationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_develop_xml_configuration_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (valaDevelopXmlConfiguration), 0, (GInstanceInitFunc) vala_develop_xml_configuration_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType vala_develop_xml_configuration_type_id;
		vala_develop_xml_configuration_type_id = g_type_register_fundamental (g_type_fundamental_next (), "valaDevelopXmlConfiguration", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&vala_develop_xml_configuration_type_id__volatile, vala_develop_xml_configuration_type_id);
	}
	return vala_develop_xml_configuration_type_id__volatile;
}

gpointer
vala_develop_xml_configuration_ref (gpointer instance)
{
	valaDevelopXmlConfiguration * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
vala_develop_xml_configuration_unref (gpointer instance)
{
	valaDevelopXmlConfiguration * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		VALA_DEVELOP_XML_CONFIGURATION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static inline gpointer
vala_develop_settings_get_instance_private (valaDevelopSettings* self)
{
	return G_STRUCT_MEMBER_P (self, valaDevelopSettings_private_offset);
}

gchar*
vala_develop_settings_get (valaDevelopSettings* self,
                           const gchar* key)
{
	gchar* result = NULL;
	GError* _inner_error0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	{
		gboolean _tmp0_ = FALSE;
		GKeyFile* _tmp1_;
		_tmp1_ = self->priv->_key;
		_tmp0_ = g_key_file_has_key (_tmp1_, "global", key, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_KEY_FILE_ERROR) {
				goto __catch69_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		if (_tmp0_) {
			gchar* _tmp2_ = NULL;
			GKeyFile* _tmp3_;
			gchar* _tmp4_;
			gchar* _tmp5_;
			_tmp3_ = self->priv->_key;
			_tmp4_ = g_key_file_get_string (_tmp3_, "global", key, &_inner_error0_);
			_tmp2_ = _tmp4_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				if (_inner_error0_->domain == G_KEY_FILE_ERROR) {
					goto __catch69_g_key_file_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
			_tmp5_ = _tmp2_;
			_tmp2_ = NULL;
			result = _tmp5_;
			_g_free0 (_tmp2_);
			return result;
		}
	}
	goto __finally69;
	__catch69_g_key_file_error:
	{
		GError* e = NULL;
		GError* _tmp6_;
		const gchar* _tmp7_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		g_log (NULL, G_LOG_LEVEL_ERROR, "xml_configuration.vala:52: %s", _tmp7_);
		_g_error_free0 (e);
	}
	__finally69:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	result = NULL;
	return result;
}

void
vala_develop_settings_set (valaDevelopSettings* self,
                           const gchar* key,
                           const gchar* val)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	{
		if (val == NULL) {
			GKeyFile* _tmp0_;
			_tmp0_ = self->priv->_key;
			g_key_file_remove_key (_tmp0_, "global", key, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				if (_inner_error0_->domain == G_KEY_FILE_ERROR) {
					goto __catch70_g_key_file_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		} else {
			GKeyFile* _tmp1_;
			_tmp1_ = self->priv->_key;
			g_key_file_set_string (_tmp1_, "global", key, val);
		}
	}
	goto __finally70;
	__catch70_g_key_file_error:
	{
		GError* e = NULL;
		GError* _tmp2_;
		const gchar* _tmp3_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		g_log (NULL, G_LOG_LEVEL_ERROR, "xml_configuration.vala:68: %s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally70:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

void
vala_develop_settings_load (valaDevelopSettings* self)
{
	GFile* home_folder = NULL;
	const gchar* _tmp0_;
	GFile* _tmp1_;
	GFile* xdg_config_home_folder = NULL;
	gchar* xdg_config_home = NULL;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_;
	GFile* _tmp13_;
	GFile* _tmp15_;
	GFile* _tmp16_;
	GFile* _tmp17_;
	GFile* _tmp18_;
	GFile* _tmp19_;
	gchar* _tmp20_;
	const gchar* _tmp21_;
	GFile* _tmp22_;
	GFile* _tmp23_;
	gboolean _tmp24_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_get_home_dir ();
	_tmp1_ = g_file_new_for_path (_tmp0_);
	home_folder = _tmp1_;
	_tmp2_ = g_getenv ("XDG_CONFIG_HOME");
	_tmp3_ = g_strdup (_tmp2_);
	xdg_config_home = _tmp3_;
	_tmp5_ = xdg_config_home;
	if (_tmp5_ == NULL) {
		_tmp4_ = TRUE;
	} else {
		const gchar* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		_tmp6_ = xdg_config_home;
		_tmp7_ = strlen (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp4_ = _tmp8_ == 0;
	}
	if (_tmp4_) {
		GFile* _tmp9_;
		GFile* _tmp10_;
		_tmp9_ = home_folder;
		_tmp10_ = g_file_get_child (_tmp9_, ".config");
		_g_object_unref0 (xdg_config_home_folder);
		xdg_config_home_folder = _tmp10_;
	} else {
		const gchar* _tmp11_;
		GFile* _tmp12_;
		_tmp11_ = xdg_config_home;
		_tmp12_ = g_file_new_for_path (_tmp11_);
		_g_object_unref0 (xdg_config_home_folder);
		xdg_config_home_folder = _tmp12_;
	}
	_tmp13_ = xdg_config_home_folder;
	if (!g_file_query_exists (_tmp13_, NULL)) {
		GFile* _tmp14_;
		_tmp14_ = xdg_config_home_folder;
		g_file_make_directory_with_parents (_tmp14_, NULL, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_free0 (xdg_config_home);
			_g_object_unref0 (xdg_config_home_folder);
			_g_object_unref0 (home_folder);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	_tmp15_ = xdg_config_home_folder;
	_tmp16_ = g_file_get_child (_tmp15_, "valaDevelop");
	_tmp17_ = _tmp16_;
	_tmp18_ = g_file_get_child (_tmp17_, "valaDevelop.config");
	_tmp19_ = _tmp18_;
	_tmp20_ = g_file_get_path (_tmp19_);
	_g_free0 (self->priv->user_config_folder);
	self->priv->user_config_folder = _tmp20_;
	_g_object_unref0 (_tmp19_);
	_g_object_unref0 (_tmp17_);
	_tmp21_ = self->priv->user_config_folder;
	_tmp22_ = g_file_new_for_path (_tmp21_);
	_tmp23_ = _tmp22_;
	_tmp24_ = !g_file_query_exists (_tmp23_, NULL);
	_g_object_unref0 (_tmp23_);
	if (_tmp24_) {
		{
			const gchar* _tmp25_;
			GFile* _tmp26_;
			GFile* _tmp27_;
			GFile* _tmp28_;
			GFile* _tmp29_;
			GKeyFile* _tmp30_;
			GKeyFile* _tmp31_;
			const gchar* _tmp32_;
			_tmp25_ = self->priv->user_config_folder;
			_tmp26_ = g_file_new_for_path (_tmp25_);
			_tmp27_ = _tmp26_;
			_tmp28_ = g_file_get_parent (_tmp27_);
			_tmp29_ = _tmp28_;
			g_file_make_directory (_tmp29_, NULL, &_inner_error0_);
			_g_object_unref0 (_tmp29_);
			_g_object_unref0 (_tmp27_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				goto __catch71_g_error;
			}
			_tmp30_ = self->priv->_key;
			g_key_file_load_from_data (_tmp30_, "\n" \
"\t\t\t\t\t\t[global]\n" \
"\t\t\t\t\t\tsolutionWindow.visible=true\n" \
"\t\t\t\t\t\toptionWindow.visible=true\n" \
"\t\t\t\t\t\tshowwarnings.active=false\n" \
"\t\t\t\t\t\tshowerrors.active=true\n" \
"\t\t\t\t\t\tstatusWindow.visible=true\n" \
"\t\t\t\t\t\tstylesheme=classic\n" \
"\t\t\t\t\t\t", (gsize) -1, G_KEY_FILE_NONE, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				goto __catch71_g_error;
			}
			_tmp31_ = self->priv->_key;
			_tmp32_ = self->priv->user_config_folder;
			g_key_file_save_to_file (_tmp31_, _tmp32_, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				goto __catch71_g_error;
			}
		}
		goto __finally71;
		__catch71_g_error:
		{
			GError* e = NULL;
			GError* _tmp33_;
			const gchar* _tmp34_;
			e = _inner_error0_;
			_inner_error0_ = NULL;
			_tmp33_ = e;
			_tmp34_ = _tmp33_->message;
			g_log (NULL, G_LOG_LEVEL_ERROR, "xml_configuration.vala:103: %s", _tmp34_);
			_g_error_free0 (e);
		}
		goto __finally71;
		__catch71_g_file_error:
		{
			GError* e = NULL;
			GError* _tmp35_;
			const gchar* _tmp36_;
			e = _inner_error0_;
			_inner_error0_ = NULL;
			_tmp35_ = e;
			_tmp36_ = _tmp35_->message;
			g_log (NULL, G_LOG_LEVEL_ERROR, "xml_configuration.vala:107: %s", _tmp36_);
			_g_error_free0 (e);
		}
		goto __finally71;
		__catch71_g_key_file_error:
		{
			GError* e = NULL;
			GError* _tmp37_;
			const gchar* _tmp38_;
			e = _inner_error0_;
			_inner_error0_ = NULL;
			_tmp37_ = e;
			_tmp38_ = _tmp37_->message;
			g_log (NULL, G_LOG_LEVEL_ERROR, "xml_configuration.vala:111: %s", _tmp38_);
			_g_error_free0 (e);
		}
		__finally71:
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_free0 (xdg_config_home);
			_g_object_unref0 (xdg_config_home_folder);
			_g_object_unref0 (home_folder);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	{
		GKeyFile* _tmp39_;
		const gchar* _tmp40_;
		_tmp39_ = self->priv->_key;
		_tmp40_ = self->priv->user_config_folder;
		g_key_file_load_from_file (_tmp39_, _tmp40_, G_KEY_FILE_NONE, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_FILE_ERROR) {
				goto __catch72_g_file_error;
			}
			if (_inner_error0_->domain == G_KEY_FILE_ERROR) {
				goto __catch72_g_key_file_error;
			}
			_g_free0 (xdg_config_home);
			_g_object_unref0 (xdg_config_home_folder);
			_g_object_unref0 (home_folder);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	goto __finally72;
	__catch72_g_file_error:
	{
		GError* e = NULL;
		GError* _tmp41_;
		const gchar* _tmp42_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp41_ = e;
		_tmp42_ = _tmp41_->message;
		g_log (NULL, G_LOG_LEVEL_ERROR, "xml_configuration.vala:120: %s", _tmp42_);
		_g_error_free0 (e);
	}
	goto __finally72;
	__catch72_g_key_file_error:
	{
		GError* e = NULL;
		GError* _tmp43_;
		const gchar* _tmp44_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp43_ = e;
		_tmp44_ = _tmp43_->message;
		g_log (NULL, G_LOG_LEVEL_ERROR, "xml_configuration.vala:124: %s", _tmp44_);
		_g_error_free0 (e);
	}
	__finally72:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (xdg_config_home);
		_g_object_unref0 (xdg_config_home_folder);
		_g_object_unref0 (home_folder);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_g_free0 (xdg_config_home);
	_g_object_unref0 (xdg_config_home_folder);
	_g_object_unref0 (home_folder);
}

void
vala_develop_settings_save (valaDevelopSettings* self)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	{
		GKeyFile* _tmp0_;
		const gchar* _tmp1_;
		_tmp0_ = self->priv->_key;
		_tmp1_ = self->priv->user_config_folder;
		g_key_file_save_to_file (_tmp0_, _tmp1_, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_FILE_ERROR) {
				goto __catch73_g_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	goto __finally73;
	__catch73_g_file_error:
	{
		GError* e = NULL;
		GError* _tmp2_;
		const gchar* _tmp3_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		g_log (NULL, G_LOG_LEVEL_ERROR, "xml_configuration.vala:136: %s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally73:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

void
vala_develop_settings_remove (valaDevelopSettings* self,
                              const gchar* key)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	{
		GKeyFile* _tmp0_;
		_tmp0_ = self->priv->_key;
		g_key_file_remove_key (_tmp0_, "global", key, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_KEY_FILE_ERROR) {
				goto __catch74_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	goto __finally74;
	__catch74_g_key_file_error:
	{
		GError* e = NULL;
		GError* _tmp1_;
		const gchar* _tmp2_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp1_ = e;
		_tmp2_ = _tmp1_->message;
		g_log (NULL, G_LOG_LEVEL_ERROR, "xml_configuration.vala:148: %s", _tmp2_);
		_g_error_free0 (e);
	}
	__finally74:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

gboolean
vala_develop_settings_has_key (valaDevelopSettings* self,
                               const gchar* key)
{
	gboolean result = FALSE;
	GError* _inner_error0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (key != NULL, FALSE);
	{
		gboolean _tmp0_ = FALSE;
		GKeyFile* _tmp1_;
		_tmp1_ = self->priv->_key;
		_tmp0_ = g_key_file_has_key (_tmp1_, "global", key, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gboolean _tmp2_ = FALSE;
			if (_inner_error0_->domain == G_KEY_FILE_ERROR) {
				goto __catch75_g_key_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp2_;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally75;
	__catch75_g_key_file_error:
	{
		GError* e = NULL;
		GError* _tmp3_;
		const gchar* _tmp4_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp3_ = e;
		_tmp4_ = _tmp3_->message;
		g_log (NULL, G_LOG_LEVEL_ERROR, "xml_configuration.vala:160: %s", _tmp4_);
		_g_error_free0 (e);
	}
	__finally75:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp5_ = FALSE;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp5_;
	}
	result = FALSE;
	return result;
}

valaDevelopSettings*
vala_develop_settings_construct (GType object_type)
{
	valaDevelopSettings* self = NULL;
	self = (valaDevelopSettings*) g_type_create_instance (object_type);
	return self;
}

valaDevelopSettings*
vala_develop_settings_new (void)
{
	return vala_develop_settings_construct (VALA_DEVELOP_TYPE_SETTINGS);
}

static void
vala_develop_value_settings_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
vala_develop_value_settings_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		vala_develop_settings_unref (value->data[0].v_pointer);
	}
}

static void
vala_develop_value_settings_copy_value (const GValue* src_value,
                                        GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = vala_develop_settings_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
vala_develop_value_settings_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
vala_develop_value_settings_collect_value (GValue* value,
                                           guint n_collect_values,
                                           GTypeCValue* collect_values,
                                           guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		valaDevelopSettings * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = vala_develop_settings_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
vala_develop_value_settings_lcopy_value (const GValue* value,
                                         guint n_collect_values,
                                         GTypeCValue* collect_values,
                                         guint collect_flags)
{
	valaDevelopSettings ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = vala_develop_settings_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
vala_develop_param_spec_settings (const gchar* name,
                                  const gchar* nick,
                                  const gchar* blurb,
                                  GType object_type,
                                  GParamFlags flags)
{
	valaDevelopParamSpecSettings* spec;
	g_return_val_if_fail (g_type_is_a (object_type, VALA_DEVELOP_TYPE_SETTINGS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
vala_develop_value_get_settings (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_DEVELOP_TYPE_SETTINGS), NULL);
	return value->data[0].v_pointer;
}

void
vala_develop_value_set_settings (GValue* value,
                                 gpointer v_object)
{
	valaDevelopSettings * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_DEVELOP_TYPE_SETTINGS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALA_DEVELOP_TYPE_SETTINGS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		vala_develop_settings_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		vala_develop_settings_unref (old);
	}
}

void
vala_develop_value_take_settings (GValue* value,
                                  gpointer v_object)
{
	valaDevelopSettings * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_DEVELOP_TYPE_SETTINGS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALA_DEVELOP_TYPE_SETTINGS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		vala_develop_settings_unref (old);
	}
}

static void
vala_develop_settings_class_init (valaDevelopSettingsClass * klass,
                                  gpointer klass_data)
{
	vala_develop_settings_parent_class = g_type_class_peek_parent (klass);
	((valaDevelopSettingsClass *) klass)->finalize = vala_develop_settings_finalize;
	g_type_class_adjust_private_offset (klass, &valaDevelopSettings_private_offset);
}

static void
vala_develop_settings_instance_init (valaDevelopSettings * self,
                                     gpointer klass)
{
	GKeyFile* _tmp0_;
	self->priv = vala_develop_settings_get_instance_private (self);
	_tmp0_ = g_key_file_new ();
	self->priv->_key = _tmp0_;
	self->ref_count = 1;
}

static void
vala_develop_settings_finalize (valaDevelopSettings * obj)
{
	valaDevelopSettings * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALA_DEVELOP_TYPE_SETTINGS, valaDevelopSettings);
	g_signal_handlers_destroy (self);
	_g_key_file_unref0 (self->priv->_key);
	_g_free0 (self->priv->user_config_folder);
}

GType
vala_develop_settings_get_type (void)
{
	static volatile gsize vala_develop_settings_type_id__volatile = 0;
	if (g_once_init_enter (&vala_develop_settings_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { vala_develop_value_settings_init, vala_develop_value_settings_free_value, vala_develop_value_settings_copy_value, vala_develop_value_settings_peek_pointer, "p", vala_develop_value_settings_collect_value, "p", vala_develop_value_settings_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (valaDevelopSettingsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_develop_settings_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (valaDevelopSettings), 0, (GInstanceInitFunc) vala_develop_settings_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType vala_develop_settings_type_id;
		vala_develop_settings_type_id = g_type_register_fundamental (g_type_fundamental_next (), "valaDevelopSettings", &g_define_type_info, &g_define_type_fundamental_info, 0);
		valaDevelopSettings_private_offset = g_type_add_instance_private (vala_develop_settings_type_id, sizeof (valaDevelopSettingsPrivate));
		g_once_init_leave (&vala_develop_settings_type_id__volatile, vala_develop_settings_type_id);
	}
	return vala_develop_settings_type_id__volatile;
}

gpointer
vala_develop_settings_ref (gpointer instance)
{
	valaDevelopSettings * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
vala_develop_settings_unref (gpointer instance)
{
	valaDevelopSettings * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		VALA_DEVELOP_SETTINGS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

